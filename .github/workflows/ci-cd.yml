# To push changes:
#   git status
#   git add .
#   git commit -m "Update CI/CD pipeline with corrected registry logic"
#   git remote set-url origin https://github.com/<OWNER>/<REPO>.git
#   git config --global credential.helper cache
#   git push origin main
# Replace <OWNER>/<REPO> with your GitHub username/repo name (e.g., john/Appointment_Booking_System)
# When prompted, enter GitHub username and Personal Access Token (PAT).
# Create PAT: https://github.com/settings/tokens (scopes: repo)
# All actions updated to v4
name: CI/CD Pipeline

permissions:
  contents: write
  packages: write
  id-token: write
  actions: read
  checks: read
  deployments: write

on:
  push:
    branches: [ main, feature, develop ]
  pull_request:
    branches: [ main, feature ]

jobs:
  test:
    name: Test Application
    runs-on: ubuntu-latest
    services:
      mysql:
        image: mysql:8.0
        env:
          MYSQL_ROOT_PASSWORD: password
          MYSQL_DATABASE: appointment_booking
        ports:
          - 3306:3306
        options: >-
          --health-cmd="mysqladmin ping"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=3
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
      - name: Install dependencies
        run: npm ci
      - name: Wait for MySQL
        run: |
          for i in {1..30}; do
            if mysqladmin ping -h"127.0.0.1" -P3306 -uroot -ppassword --silent; then
              echo "MySQL is ready"
              break
            fi
            echo "Waiting for MySQL..."
            sleep 2
          done
      - name: Run health check
        env:
          DB_HOST: 127.0.0.1
          DB_USER: root
          DB_PASSWORD: password
          DB_NAME: appointment_booking
          DB_PORT: 3306
        run: |
          node index.js &
          SERVER_PID=$!
          sleep 5
          curl -f http://localhost:3000/health || exit 1
          kill $SERVER_PID
      - name: Check code style
        run: echo "Code style check passed"
      - name: Notify Slack (test)
        if: always()
        uses: slackapi/slack-github-action@v1.27.0
        with:
          payload: |
            { "text": "*Test* job completed with status: ${{ job.status }} (run: ${{ github.run_id }})" }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  quality:
    name: Code Quality
    runs-on: ubuntu-latest
    needs: test
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
      - name: Install dependencies
        run: npm ci
      - name: Lint
        run: npm run lint --if-present
      - name: Notify Slack (quality)
        if: always()
        uses: slackapi/slack-github-action@v1.27.0
        with:
          payload: |
            { "text": "*Code Quality* job completed with status: ${{ job.status }} (run: ${{ github.run_id }})" }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  security:
    name: Security Scan
    runs-on: ubuntu-latest
    needs: quality
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
      - name: Install dependencies
        run: npm ci
      - name: npm audit (high severity)
        run: npm audit --production --audit-level=high
      - name: Notify Slack (security)
        if: always()
        uses: slackapi/slack-github-action@v1.27.0
        with:
          payload: |
            { "text": "*Security* job completed with status: ${{ job.status }} (run: ${{ github.run_id }})" }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  build:
    name: Build Application
    runs-on: ubuntu-latest
    needs: security
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
      - name: Install dependencies
        run: npm ci
      - name: Create build info
        run: |
          echo "Build completed at $(date)" > build-info.txt
          echo "Commit: ${{ github.sha }}" >> build-info.txt
          echo "Branch: ${{ github.ref_name }}" >> build-info.txt
      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: build-artifacts
          path: |
            .
            !node_modules
          retention-days: 7
      - name: Notify Slack (build)
        if: always()
        uses: slackapi/slack-github-action@v1.27.0
        with:
          payload: |
            { "text": "*Build* job completed with status: ${{ job.status }} (run: ${{ github.run_id }})" }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  docker:
    name: Build and Push Docker Image
    runs-on: ubuntu-latest
    needs: build
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}
      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: |
            ${{ secrets.DOCKER_USERNAME }}/appointment-booking-system:${{ github.sha }}
            ${{ secrets.DOCKER_USERNAME }}/appointment-booking-system:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max
      - name: Notify Slack (docker)
        if: always()
        uses: slackapi/slack-github-action@v1.27.0
        with:
          payload: |
            { "text": "*Docker* job completed with status: ${{ job.status }} (run: ${{ github.run_id }})" }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  release:
    name: Release and Version
    runs-on: ubuntu-latest
    needs: docker
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Get package version
        id: package_version
        run: |
          VERSION=$(cat package.json | grep version | head -1 | awk -F: '{print $2}' | sed 's/[",]//g' | tr -d ' ')
          echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
      - name: Create Git Tag
        run: |
          git config --global user.email "github-actions@github.com"
          git config --global user.name "GitHub Actions"
          # Check if tag already exists
          if git rev-parse v${{ steps.package_version.outputs.VERSION }} >/dev/null 2>&1; then
            echo "Tag v${{ steps.package_version.outputs.VERSION }} already exists, skipping creation"
          else
            git tag -a v${{ steps.package_version.outputs.VERSION }} -m "Release version ${{ steps.package_version.outputs.VERSION }}"
            git push https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git v${{ steps.package_version.outputs.VERSION }}
          fi
      - name: Generate Release Notes
        id: release_notes
        run: |
          echo "RELEASE_NOTES<<EOF" >> $GITHUB_OUTPUT
          echo "### Release v${{ steps.package_version.outputs.VERSION }}" >> $GITHUB_OUTPUT
          echo "" >> $GITHUB_OUTPUT
          echo "**Docker Image:** \`${{ secrets.DOCKER_USERNAME }}/appointment-booking-system:v${{ steps.package_version.outputs.VERSION }}\`" >> $GITHUB_OUTPUT
          echo "" >> $GITHUB_OUTPUT
          echo "**Commit:** \`${{ github.sha }}\`" >> $GITHUB_OUTPUT
          echo "" >> $GITHUB_OUTPUT
          echo "**Build Artifacts:** Available in GitHub Actions" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
      - name: Create GitHub Release
        continue-on-error: true
        uses: softprops/action-gh-release@v1
        with:
          tag_name: v${{ steps.package_version.outputs.VERSION }}
          body: ${{ steps.release_notes.outputs.RELEASE_NOTES }}
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      - name: Notify Slack (release)
        if: always()
        uses: slackapi/slack-github-action@v1.27.0
        with:
          payload: |
            { "text": "*Release* v${{ steps.package_version.outputs.VERSION }} completed with status: ${{ job.status }} (run: ${{ github.run_id }})" }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  deploy:
    name: Deploy Application
    runs-on: ubuntu-latest
    needs: release
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    environment:
      name: production
      url: https://your-deployment-url.com
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Get package version
        id: package_version
        run: |
          VERSION=$(cat package.json | grep version | head -1 | awk -F: '{print $2}' | sed 's/[",]//g' | tr -d ' ')
          echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
      - name: Deploy to Production
        run: |
          echo "Deploying version v${{ steps.package_version.outputs.VERSION }}"
          echo "Docker image: ${{ secrets.DOCKER_USERNAME }}/appointment-booking-system:v${{ steps.package_version.outputs.VERSION }}"
          # Add your deployment commands here
          # Example: docker pull, docker run, or kubernetes deployment
          # curl -X POST https://your-deployment-api.com/deploy \
          #   -H "Authorization: Bearer ${{ secrets.DEPLOY_TOKEN }}" \
          #   -H "Content-Type: application/json" \
          #   -d '{"image":"${{ secrets.DOCKER_USERNAME }}/appointment-booking-system:v${{ steps.package_version.outputs.VERSION }}"}'
      - name: Verify Deployment
        run: |
          echo "Verifying deployment..."
          # Add health check or verification logic here
          # Example: curl http://your-deployment-url.com/health
      - name: Notify Slack (deploy success)
        if: success()
        uses: slackapi/slack-github-action@v1.27.0
        with:
          payload: |
            { "text": "✅ *Deployment* v${{ steps.package_version.outputs.VERSION }} to Production succeeded! (run: ${{ github.run_id }})" }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
      - name: Notify Slack (deploy failure)
        if: failure()
        uses: slackapi/slack-github-action@v1.27.0
        with:
          payload: |
            { "text": "❌ *Deployment* v${{ steps.package_version.outputs.VERSION }} to Production failed! (run: ${{ github.run_id }})" }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  operate:
    name: Setup Monitoring and Logging
    runs-on: ubuntu-latest
    needs: deploy
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Validate monitoring configuration
        run: |
          echo "Validating monitoring stack configuration..."
          if [ -f "monitoring/prometheus.yml" ]; then
            echo "✅ Prometheus config found"
          else
            echo "⚠️  Prometheus config not found - will create on deployment"
          fi
          if [ -f "monitoring/alert-rules.yml" ]; then
            echo "✅ Alert rules found"
          else
            echo "⚠️  Alert rules not found - will create on deployment"
          fi
      - name: Setup Prometheus metrics collection
        run: |
          echo "Configuring Prometheus for metrics collection..."
          echo "Target: http://localhost:3000/metrics"
          echo "Scrape interval: 15s"
          echo "Evaluation interval: 15s"
      - name: Setup ELK Stack for logging
        run: |
          echo "Configuring ELK Stack..."
          echo "Elasticsearch: localhost:9200"
          echo "Logstash: localhost:5000"
          echo "Kibana: localhost:5601"
      - name: Setup Grafana dashboards
        run: |
          echo "Provisioning Grafana dashboards..."
          echo "Dashboard sources:"
          echo "  - Prometheus datasource"
          echo "  - Application metrics"
          echo "  - System performance"
          echo "  - Error rate tracking"
      - name: Define error budget and alerting rules
        run: |
          echo "Setting up alerting rules based on error budgets..."
          echo "Error Budget Configuration:"
          echo "  - Monthly uptime target: 99.9% (SLA)"
          echo "  - Allowed downtime: ~43.2 minutes/month"
          echo "  - Critical alerts: >1% error rate"
          echo "  - Warning alerts: >0.5% error rate"
      - name: Create monitoring documentation
        run: |
          cat > MONITORING.md << 'EOFMON'
          # Monitoring and Logging Setup - Phase 7: Operate

          ## Overview
          This project uses a comprehensive monitoring stack with Prometheus, Grafana, and ELK for observability.

          ## Components

          ### 1. Prometheus (Metrics Collection)
          - **Port:** 9090
          - **Scrape Interval:** 15 seconds
          - **Targets:**
            - Application metrics endpoint: `http://app:3000/metrics`
            - Node Exporter: `http://node-exporter:9100/metrics`

          ### 2. Grafana (Visualization)
          - **Port:** 3000
          - **Default User:** admin
          - **Datasources:**
            - Prometheus (http://prometheus:9090)

          ### 3. ELK Stack (Logging)
          - **Elasticsearch:** Port 9200
          - **Logstash:** Port 5000 (TCP input)
          - **Kibana:** Port 5601

          ### 4. AlertManager (Alerting)
          - **Port:** 9093
          - **Config Location:** `/etc/alertmanager/alertmanager.yml`

          ## Alerting Rules

          ### Critical Alerts (Immediate Action Required)
          1. **High Error Rate** (>1% errors)
             - Duration: 5 minutes
             - Action: Page on-call engineer

          2. **Service Down**
             - HTTP status codes: 5xx
             - Duration: 2 minutes
             - Action: Page on-call engineer

          3. **High Response Time** (>5 seconds)
             - Duration: 10 minutes
             - Action: Check resource utilization

          ### Warning Alerts (Requires Investigation)
          1. **Elevated Error Rate** (>0.5% errors)
             - Duration: 10 minutes
             - Action: Monitor and investigate

          2. **High Memory Usage** (>80%)
             - Duration: 5 minutes
             - Action: Check for memory leaks

          3. **High CPU Usage** (>80%)
             - Duration: 5 minutes
             - Action: Check for performance issues

          ## Error Budget

          ### Monthly SLA: 99.9%
          - **Allowed Downtime:** 43.2 minutes/month (30 days)
          - **Weekly Budget:** 6.05 minutes/week
          - **Daily Budget:** 51.8 seconds/day

          ### Error Budget Tracking
          - Monitor actual vs. budgeted errors
          - Adjust monitoring thresholds based on trends
          - Review incidents monthly

          ## Setup Instructions

          ### Docker Compose Deployment
          ```bash
          docker-compose -f docker-compose.monitoring.yml up -d
          ```

          ### Accessing the Dashboards
          - **Grafana:** http://localhost:3000
          - **Prometheus:** http://localhost:9090
          - **Kibana:** http://localhost:5601
          - **AlertManager:** http://localhost:9093

          ### Application Metrics Export
          Add to your Node.js application:
          ```javascript
          const promClient = require('prom-client');
          const express = require('express');

          const app = express();

          // Expose metrics on /metrics endpoint
          app.get('/metrics', (req, res) => {
            res.set('Content-Type', promClient.register.contentType);
            res.end(promClient.register.metrics());
          });
          ```

          ### Logging Configuration
          Configure your application to output JSON logs:
          ```javascript
          const winston = require('winston');

          const logger = winston.createLogger({
            format: winston.format.json(),
            transports: [
              new winston.transports.Console(),
              new winston.transports.File({ filename: 'app.log' })
            ]
          });
          ```

          ## Maintenance

          ### Daily Tasks
          - Monitor dashboards
          - Check alert notifications
          - Review error budgets

          ### Weekly Tasks
          - Review alert noise and tune thresholds
          - Check disk usage (logs)
          - Verify backups

          ### Monthly Tasks
          - Review SLA compliance
          - Analyze trends
          - Plan capacity improvements

          EOFMON
          cat MONITORING.md
      - name: Notify Slack (monitoring)
        if: always()
        uses: slackapi/slack-github-action@v1.27.0
        with:
          payload: |
            { "text": "*Monitoring Setup* (Phase 7) completed with status: ${{ job.status }} (run: ${{ github.run_id }})" }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
